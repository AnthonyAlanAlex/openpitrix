// Copyright 2018 The OpenPitrix Authors. All rights reserved.
// Use of this source code is governed by a Apache license
// that can be found in the LICENSE file.

// Auto generated by 'go run gen_helper.go', DO NOT EDIT.

package labelutil

import (
	"context"

	"openpitrix.io/openpitrix/pkg/db"
	"openpitrix.io/openpitrix/pkg/gerr"
	"openpitrix.io/openpitrix/pkg/models"
	"openpitrix.io/openpitrix/pkg/pi"
)

func SyncRepoLabels(ctx context.Context, repoId, labelStr string) error {
	labelMap, err := Parse(labelStr)
	if err != nil {
		return gerr.NewWithDetail(ctx, gerr.InvalidArgument, err, gerr.ErrorParameterParseFailed, "label")
	}
	var labels []*models.RepoLabel
	_, err = pi.Global().DB(ctx).
		Select(models.RepoLabelColumns...).
		From(models.RepoLabelTableName).
		Where(db.Eq(models.ColumnRepoId, repoId)).
		OrderDir(models.ColumnCreateTime, true).
		Load(&labels)
	if err != nil {
		return gerr.NewWithDetail(ctx, gerr.InvalidArgument, err, gerr.ErrorDescribeResourcesFailed)
	}
	i := 0
	// update exists label
	// insert new label
	// delete outmoded label
	insert := pi.Global().DB(ctx).InsertInto(models.RepoLabelTableName).Columns(models.RepoLabelColumns...)
	for key, values := range labelMap {
		for _, value := range values {
			if len(labels) >= i+1 {
				label := labels[i]
				if label.LabelKey != key || label.LabelValue != value {
					_, err = pi.Global().DB(ctx).
						Update(models.RepoLabelTableName).
						Set(models.ColumnLabelKey, key).
						Set(models.ColumnLabelValue, value).
						Where(db.Eq(models.ColumnRepoLabelId, label.RepoLabelId)).
						Exec()
					if err != nil {
						return gerr.NewWithDetail(ctx, gerr.Internal, err, gerr.ErrorModifyResourcesFailed)
					}
				}
			} else {
				repoLabel := models.NewRepoLabel(repoId, key, value)
				insert = insert.Record(repoLabel)
			}
			i++
		}
	}
	if len(insert.Value) > 0 {
		_, err = insert.Exec()
		if err != nil {
			return gerr.NewWithDetail(ctx, gerr.Internal, err, gerr.ErrorModifyResourcesFailed)
		}
	}
	if len(labels) >= i+1 {
		var deleteLabelIds []string
		labels = labels[i:]
		for _, label := range labels {
			deleteLabelIds = append(deleteLabelIds, label.RepoLabelId)
		}
		_, err := pi.Global().DB(ctx).
			DeleteFrom(models.RepoLabelTableName).
			Where(db.Eq(models.ColumnRepoLabelId, deleteLabelIds)).
			Exec()
		if err != nil {
			return gerr.NewWithDetail(ctx, gerr.Internal, err, gerr.ErrorModifyResourcesFailed)
		}
	}
	return err
}

func SyncRepoSelectors(ctx context.Context, repoId, selectorStr string) error {
	selectorMap, err := Parse(selectorStr)
	if err != nil {
		return gerr.NewWithDetail(ctx, gerr.InvalidArgument, err, gerr.ErrorParameterParseFailed, "selector")
	}
	var selectors []*models.RepoSelector
	_, err = pi.Global().DB(ctx).
		Select(models.RepoSelectorColumns...).
		From(models.RepoSelectorTableName).
		Where(db.Eq(models.ColumnRepoId, repoId)).
		OrderDir(models.ColumnCreateTime, true).
		Load(&selectors)
	if err != nil {
		return gerr.NewWithDetail(ctx, gerr.InvalidArgument, err, gerr.ErrorDescribeResourcesFailed)
	}
	i := 0
	// update exists selector
	// insert new selector
	// delete outmoded selector
	insert := pi.Global().DB(ctx).InsertInto(models.RepoSelectorTableName).Columns(models.RepoSelectorColumns...)
	for key, values := range selectorMap {
		for _, value := range values {
			if len(selectors) >= i+1 {
				selector := selectors[i]
				if selector.SelectorKey != key || selector.SelectorValue != value {
					_, err = pi.Global().DB(ctx).
						Update(models.RepoSelectorTableName).
						Set(models.ColumnSelectorKey, key).
						Set(models.ColumnSelectorValue, value).
						Where(db.Eq(models.ColumnRepoSelectorId, selector.RepoSelectorId)).
						Exec()
					if err != nil {
						return gerr.NewWithDetail(ctx, gerr.Internal, err, gerr.ErrorModifyResourcesFailed)
					}
				}
			} else {
				repoSelector := models.NewRepoSelector(repoId, key, value)
				insert = insert.Record(repoSelector)
			}
			i++
		}
	}
	if len(insert.Value) > 0 {
		_, err = insert.Exec()
		if err != nil {
			return gerr.NewWithDetail(ctx, gerr.Internal, err, gerr.ErrorModifyResourcesFailed)
		}
	}
	if len(selectors) >= i+1 {
		var deleteSelectorIds []string
		selectors = selectors[i:]
		for _, selector := range selectors {
			deleteSelectorIds = append(deleteSelectorIds, selector.RepoSelectorId)
		}
		_, err := pi.Global().DB(ctx).
			DeleteFrom(models.RepoSelectorTableName).
			Where(db.Eq(models.ColumnRepoSelectorId, deleteSelectorIds)).
			Exec()
		if err != nil {
			return gerr.NewWithDetail(ctx, gerr.Internal, err, gerr.ErrorModifyResourcesFailed)
		}
	}
	return err
}

func SyncRuntimeLabels(ctx context.Context, runtimeId, labelStr string) error {
	labelMap, err := Parse(labelStr)
	if err != nil {
		return gerr.NewWithDetail(ctx, gerr.InvalidArgument, err, gerr.ErrorParameterParseFailed, "label")
	}
	var labels []*models.RuntimeLabel
	_, err = pi.Global().DB(ctx).
		Select(models.RuntimeLabelColumns...).
		From(models.RuntimeLabelTableName).
		Where(db.Eq(models.ColumnRuntimeId, runtimeId)).
		OrderDir(models.ColumnCreateTime, true).
		Load(&labels)
	if err != nil {
		return gerr.NewWithDetail(ctx, gerr.InvalidArgument, err, gerr.ErrorDescribeResourcesFailed)
	}
	i := 0
	// update exists label
	// insert new label
	// delete outmoded label
	insert := pi.Global().DB(ctx).InsertInto(models.RuntimeLabelTableName).Columns(models.RuntimeLabelColumns...)
	for key, values := range labelMap {
		for _, value := range values {
			if len(labels) >= i+1 {
				label := labels[i]
				if label.LabelKey != key || label.LabelValue != value {
					_, err = pi.Global().DB(ctx).
						Update(models.RuntimeLabelTableName).
						Set(models.ColumnLabelKey, key).
						Set(models.ColumnLabelValue, value).
						Where(db.Eq(models.ColumnRuntimeLabelId, label.RuntimeLabelId)).
						Exec()
					if err != nil {
						return gerr.NewWithDetail(ctx, gerr.Internal, err, gerr.ErrorModifyResourcesFailed)
					}
				}
			} else {
				repoLabel := models.NewRuntimeLabel(runtimeId, key, value)
				insert = insert.Record(repoLabel)
			}
			i++
		}
	}
	if len(insert.Value) > 0 {
		_, err = insert.Exec()
		if err != nil {
			return gerr.NewWithDetail(ctx, gerr.Internal, err, gerr.ErrorModifyResourcesFailed)
		}
	}
	if len(labels) >= i+1 {
		var deleteLabelIds []string
		labels = labels[i:]
		for _, label := range labels {
			deleteLabelIds = append(deleteLabelIds, label.RuntimeLabelId)
		}
		_, err := pi.Global().DB(ctx).
			DeleteFrom(models.RuntimeLabelTableName).
			Where(db.Eq(models.ColumnRuntimeLabelId, deleteLabelIds)).
			Exec()
		if err != nil {
			return gerr.NewWithDetail(ctx, gerr.Internal, err, gerr.ErrorModifyResourcesFailed)
		}
	}
	return err
}
